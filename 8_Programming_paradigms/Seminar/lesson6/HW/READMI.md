Выбор парадигмы программирования зависит от множества факторов, включая характер задачи, требования проекта, командные соглашения и предпочтения разработчиков. В данном случае, объектно-ориентированная парадигма была выбрана по следующим причинам:

## 1. Модульность и структура кода:

Объектно-ориентированная парадигма способствует созданию модульного и структурированного кода. Секундомер может быть естественно представлен как объект со свойствами (время, статус) и методами (запуск, пауза, остановка).
## 2. Инкапсуляция:

Использование классов позволяет инкапсулировать данные и методы, что означает их объединение внутри объекта. Это способствует улучшению управляемости кода и сокрытию деталей реализации.
## 3. Унаследование и полиморфизм:

Возможность использования унаследования и полиморфизма может быть полезной для будущего расширения функциональности секундомера. Это позволяет создавать производные классы с дополнительными возможностями, сохраняя при этом основной интерфейс.
## 4. Читаемость и поддержка кода:

Объектно-ориентированный код часто более понятен для разработчиков, так как он отражает структуру и взаимодействие объектов в реальном мире. Это делает код более читаемым и поддерживаемым в долгосрочной перспективе.
## 5. Сопоставление с реальными объектами:

Секундомер естественным образом соответствует объектно-ориентированной модели, где мы можем рассматривать его как отдельный объект с состоянием и поведением.
В целом, выбор парадигмы зависит от специфики задачи и предпочтений команды разработчиков. Объектно-ориентированная парадигма обычно подходит для моделирования реальных объектов и их взаимодействия, что может сделать код более структурированным и легким для понимания.

## Помимо ООП применен паттерн проектирования MVC (Model-View-Controller). Этот паттерн распределяет компоненты приложения на три основных типа:
* Модель (Model): Отвечает за обработку данных и бизнес-логику. В коде это класс Model.
* Представление (View): Отвечает за отображение данных пользователю. Класс View выполняет эту роль.
* Контроллер (Controller): Отвечает за обработку пользовательского ввода и управление взаимодействием между Моделью и Представлением. Этот функционал реализован в классе Presenter.
